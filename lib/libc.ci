[.db]
12=BYTE
[.dd]
12=DWORD
[.dq]
12=QWORD
[.dw]
12=WORD
[.file]
11=%dz%\include\
23=%dz%\source\libc\
[__wcpath]
1=b
2=l
3=p
8=eax: ptr
9=ecx: count
10=edx: ?
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
19=strlen
20=.dd
21=.dd
22=.dd
23=consx/robj/__wcpath.asm
[__wputs]
1=esi string
2=edi wp
3=cl  max
4=ch  at &
5=edx l
6=ah  at
8=count
11=consx.inc
12=eax,ecx
20=.dd
23=consx/robj/__wputs.asm
[_argc]
0=int _argc;
11=stdlib.inc
12=DWORD
23=stdlib/_argv.asm
[_argv]
0=char *_argv[];
11=stdlib.inc
12=DWORD
23=stdlib/_argv.asm
[_bufin]
11=stdio.inc
12=BYTE 4096
23=stdio/_bufin.asm
[_C_ESCAPE]
0=/* return from event handler */
11=consx.inc
12=3
14=_C_NORMAL
15=_C_RETURN
16=_C_ESCAPE
17=_C_REOPEN
[_C_NORMAL]
0=/* return from event handler */
11=consx.inc
12=1
14=_C_NORMAL
15=_C_RETURN
16=_C_ESCAPE
17=_C_REOPEN
[_C_REOPEN]
0=/* return from event handler */
11=consx.inc
12=4
14=_C_NORMAL
15=_C_RETURN
16=_C_ESCAPE
17=_C_REOPEN
[_C_RETURN]
0=/* return from event handler */
11=consx.inc
12=2
14=_C_NORMAL
15=_C_RETURN
16=_C_ESCAPE
17=_C_REOPEN
[_close]
0=void _close(int handle);
1=handle
8=EAX on call
9=returned in EDX
11=io.inc
12=eax,ecx,edx
13=.dd
19=CloseHandle
23=io/_close.asm
[_disk_exist]
0=DISK *_disk_exist(int disk);
1=disk A:=1
8=S_DISK *
11=direct.inc
12=eax
13=.dd
20=.dd
23=direct/disk/_disk_exist.asm
[_disk_init]
0=int _disk_init(int disk);
1=disk
8=disk
11=direct.inc
12=eax,ecx,edx
13=.dd
17=_disk_test
18=beep
19=_disk_select
20=.dd
23=direct/disk/_disk_init.asm
[_disk_read]
0=void _disk_read(void);
11=direct.inc
12=eax,edx,ecx
23=dir/drvinfo.asm
[_disk_ready]
0=int _disk_ready(int disk);
1=disk
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
18=validdrive
19=GetVolumeInformation
20=.dd
23=direct/disk/_disk_ready.asm
[_disk_retry]
0=int _disk_retry(int disk);
1=disk
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
18=rsopen
19=dlmodal
20=.dd
23=direct/disk/_disk_test.asm
[_disk_select]
0=int _disk_select(char *title);
1=title
8=drive
11=direct.inc
12=eax,ecx,edx
13=.dd
15=getdrive
16=_disk_read
17=_disk_exist
18=dlopen
19=dlmodal
20=.dd
23=direct/disk/_disk_select.asm
[_disk_test]
0=int _disk_test(int disk);
1=disk
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
17=_disk_ready
18=_disk_type
19=_disk_retry
20=.dd
23=direct/disk/_disk_test.asm
[_disk_type]
0=int _disk_type(int disk);
1=disk
8=type
11=direct.inc
12=eax,ecx,edx
13=.dd
19=GetDriveType
20=.dd
23=direct/disk/_disk_type.asm
[_diskflag]
11=io.inc
12=DWORD
23=direct/disk/_diskflag.asm
[_environ]
0=char *_environ[];
11=stdlib.inc
12=DWORD
23=stdlib/_environ.asm
[_filebuf]
0=int _filebuf(FILE *);
1=fp
8=char
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
18=_getbuf
19=read
20=.dd
23=stdio/_filebuf.asm
[_flsbuf]
0=int _flsbuf(int ch, FILE *fp);
1=ch
2=fp
8=ch
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=S_FILE
17=isatty
18=write
19=lseek
20=.dd
23=stdio/_flsbuf.asm
[_freebuf]
0=void _freebuf(FILE *);
1=fp
12=eax,ecx,edx
13=S_FILE
19=free
23=stdio/_freebuf.asm
[_ftbuf]
0=void _ftbuf(int flag, FILE *);
1=flag
2=FILE
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=S_FILE
19=fflush
23=stdio/_ftbuf.asm
[_getbuf]
0=int _getbuf(FILE *);
1=fp
8=BOOL
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
19=malloc
20=.dd
23=stdio/_getbuf.asm
[_getst]
0=FILE *_getst(void);
8=FILE
11=stdio.inc
12=eax,edx
20=S_FILE
23=stdio/_getst.asm
[_INTIOBUF]
11=stdio.inc
12=4096
13=1000h
[_iob]
11=stdio.inc
12=FILE[_NFILE_]
23=stdio/_file.asm
[_memicmp]
0=int _memicmp(void *des, void *src, size_t len);
1=des
2=src
3=len
8=0, 1, -1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/_memicmp.asm
[_nfile]
11=io.inc
12=DWORD
23=io/_ioinit.asm
[_osfhnd]
11=io.inc
12=DWORD[]
23=io/_ioinit.asm
[_osfile]
11=io.inc
12=BYTE[]
23=io/_ioinit.asm
[_output]
0=int _output(FILE *, char *format, void *argptr);
1=fp
2=format
3=argptr
8=count
11=stdio.inc
12=eax
13=S_FILE
14=.dd
15=.dd
20=.dd
23=stdio/_output.asm
[_print]
0=int _cdecl _print(char *format, ...);
1=format
2=VARARG
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=...
18=ftobufin
19=write
20=.dd
23=stdio/_print.asm
[_scrcol]
11=consx.inc
12=DWORD
23=consx/console/InitConsole.asm
[_scrrow]
11=consx.inc
12=DWORD
23=consx/console/InitConsole.asm
[_stbuf]
0=int _stbuf(FILE *);
1=FILE
8=BOOL
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
18=isatty
19=malloc
20=.dd
23=stdio/_stbuf.asm
[_umaskval]
11=io.inc
12=DWORD
23=io/_umaskval.asm
[access]
0=int access(char *path, int mode);
1=path
2=mode
8=0,-1
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=getfattr
20=.dd
23=io/access.asm
[alloca]
0=void *alloca(int);
1=byte count
8=void *
11=alloc.inc
12=eax ecx
13=.dd
20=.dd
23=alloc/alloca.asm
[allocseg]
0=void *allocseg(void);
8=void *
11=alloc.inc
12=eax,edx,ecx
19=malloc
20=.dd
23=alloc/allocseg.asm
[at_background]
11=consx.inc
12= 8 byte - X0h
13=.db
15=S_COLOR
17=at_background
18=at_foreground
19=at_palett
23=color.asm
[at_foreground]
11=consx.inc
12=16 byte - 0Xh
13=.db
15=S_COLOR
17=at_background
18=at_foreground
19=at_palett
23=color.asm
[atodate]
0=unsigned atodate(char *string);
3=dd.mm.yy | yyyy
4=mm/dd/yy | yyyy
5=yyyy-mm-dd
8=yyyyyyymmmmddddd
11=time.inc
12=eax
13=.dd
20=.dd
23=time/atodate.asm
[atohex]
0=char *atohex(char *s1);
1=s1 - 128 byte
8=s1
11=string.inc
12=eax,ecx,edx
13=.dd
15=strlen
20=.dd
23=string/atohex.asm
[atoi]
0=int atoi(char *string);
1=string
8=eax value
11=stdlib.inc
12=eax,edx
13=.dd
19=atol
20=.dd
23=stdlib/atoi.asm
[atol]
0=long atol(char *string);
1=string
8=eax value
11=stdlib.inc
12=eax ecx edx
13=.dd
20=.dd
23=stdlib/atol.asm
[atol64]
0=long atol64(char *string);
1=string
8=edx:eax value
11=stdlib.inc
12=eax edx
13=.dd
20=.dq
23=stdlib/atol64.asm
[atotime]
0=int atotime(char *string)
1=hh:mm:ss
8=hhhhmmmmmmmsssss
11=time.inc
12=eax
13=.dd
20=.dd
23=time/atotime.asm
[beep]
0=void Beep(int hz, int time);
1=hz
2=time
11=stdlib.inc
12=kernel32
13=.dd
14=.dd
[calloc]
0=void *calloc(int num, int size);
1=num
2=size
8=void *
11=alloc.inc
12=eax,edx,ecx
13=.dd
14=.dd
16=malloc
20=.dd
23=alloc/calloc.asm
[chdir]
0=int chdir(char *directory);
1=directory
8=0,-1
11=direct.inc
12=eax,ecx,edx
13=.dd
17=SetCurrentDirectory
18=GetCurrentDirectory
19=SetEnvironmentVariable
20=.dd
23=dir/chdir.asm
[chdrive]
0=int chdrive(int drive);
1=drive A: = 1
11=direct.inc
12=eax,ecx,edx
13=.dd
19=SetCurrentDirectory
20=.dd
23=dir/chdrive.asm
[chsize]
0=int chsize(int handle, long new_size);
1=handle
2=new_size
8=0
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
18=lseek
19=oswrite
20=.dd
23=io/chsize.asm
[Clipboard]
11=clip.inc
12=DWORD
23=tinfo/Clipboard.asm
[ClipboardCopy]
0=int ClipboardCopy(char *string, int len);
1=string
2=len
8=BOOL
11=clip.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=ClipboardFree
16=OpenClipboard
17=GlobalAlloc
18=GlobalLock
19=memcpy
20=.dd
23=tinfo/Clipboard.asm
[ClipboardFree]
0=void ClipboardFree(void);
11=clip.inc
12=eax,ecx
19=free
23=tinfo/Clipboard.asm
[ClipboardPaste]
0=char *ClipboardPaste(void);
8=data
11=clip.inc
12=eax,edx,ecx
13=IsClipboardFormatAvailable
14=OpenClipboard
15=GetClipboardData
16=strlen
17=malloc
18=strcpy
19=CloseClipboard
20=.dd
23=tinfo/Clipboard.asm
[Clipbsize]
11=clip.inc
12=DWORD
23=tinfo/Clipboard.asm
[close]
0=void close(int handle);
1=handle
8=EAX on call
9=returned in EDX
11=io.inc
12=eax,ecx,edx
13=.dd
19=CloseHandle
23=io/close.asm
[CloseClipboard]
0=void CloseClipboard(void);
11=clip.inc
12=user32
[CloseHandle]
11=io.inc
12=kernel32
[CMFAILED]
11=tinfo.inc
12=2
[cmpwarg]
0=int cmpwarg(char *path, char *mask);
1=path
2=mask
8=BOOL
11=string.inc
12=eax,edx
13=.dd
14=.dd
20=.dd
23=string/cmpwarg.asm
[cmpwargs]
0=int cmpwargs(char *path, char *mask);
1=path
2=mask
8=BOOL
11=string.inc
12=eax,edx
13=.dd
14=.dd
16=strchr
17=cmpwarg
20=.dd
23=string/cmpwargs.asm
[cmsearchidd]
0=int cmsearchidd(void);
8=dlevent
11=iost.inc
12=eax,ecx,edx
20=.dd
23=iost/cmsearchidd.asm
[comspec]
0=char *comspec;
11=stdlib.inc
12=DWORD
23=stdlib/comspec.asm
[comspex]
0=char *comspex;
11=stdlib.inc
12=DWORD
23=stdlib/comspec.asm
[confirm.inc]
11=confirm.inc
13=.h
[confirm_continue]
0=int confirm_continue(char *msg);
1=msg
8=BOOL
11=confirm.inc
12=eax,ecx,edx
13=.dd
16=scpath
17=rsopen
18=dlshow
19=dlmodal
20=.dd
23=consx/confirm/confirm_continue.asm
[confirm_delete]
0=int confirm_delete(char *info, int selected);
1=info
2=selected
8=BOOL
11=confirm.inc
12=eax,ecx,edx
13=.dd
14=.dd
17=rsopen
18=dlshow
19=scputf
20=.dd
23=consx/confirm/confirm_delete.asm
[confirm_delete_file]
0=int confirm_delete_file(char *file, int attrib);
1=file
2=attrib
8=BOOL
11=confirm.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=confirm_delete
20=.dd
23=consx/confirm/confirm_delete_file.asm
[confirm_delete_sub]
0=int confirm_delete_sub(char *directory);
1=directory
8=BOOL
11=confirm.inc
12=eax,ecx,edx
13=.dd
19=confirm_delete
20=.dd
23=consx/confirm/confirm_delete_sub.asm
[console]
11=consx.inc
12=DWORD
23=conio/console/console.asm
[console_cu]
11=consx.inc
12=S_CURSOR
23=conio/console/consinit.asm
[console_dl]
11=consx.inc
12=S_DOBJ
23=conio/console/consinit.asm
[consrect]
0=RECT consrect(void);
8=S_RECT
11=consx.inc
12=eax
18=_scrcol
19=_scrrow
20=.dd
23=conio/console/consrect.asm
[conssetl]
0=int conssetl(int line);
1=line 24..max
8=_scrrow
11=consx.inc
12=eax,ecx,edx
13=.dd
16=GetConsoleScreenBufferInfo
17=GetLargestConsoleWindowSize
18=sprintf
19=system
20=.dd
23=conio/console/conssetl.asm
[consuser]
0=void consuser(void);
11=consx.inc
12=eax,ecx,edx
15=cursorget
16=cursorset
17=dlshow
18=getkey
19=dlhide
23=conio/console/consuser.asm
[consx.inc]
11=consx.inc
13=.h
[CONTINUE]
11=tinfo.inc
12=0
[continuesearch]
0=int continuesearch(void);
8=BOOL
11=iost.inc
12=eax,ecx,edx
15=wcpushst
16=scputs
17=oseekl
18=osearch
19=wcpopst
20=.dd
23=iost/osearch.asm
[coreleft]
0=int coreleft(void);
8=int
11=alloc.inc
12=eax ecx edx
20=.dd
23=alloc/coreleft.asm
[creat]
0=int creat(char *path, int amode);
1=path
2=amode
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=osopen
23=io/creat.asm
[CreateConsole]
0=int CreateConsole(char *cmd, int flag);
1=cmd
2=flag
8=BOOL
11=process.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=searchp
16=strcpy
17=strcat
18=process
19=SetKeyState
20=.dd
23=process/CreateConsole.asm
[CreateDirectory]
11=direct.inc
12=kernel32
[CreateFile]
11=io.inc
12=kernel32
[Getcursor]
0=int Getcursor(CURSOR *);
1=*
8=S_CURSOR.bVisible
11=consx.inc
12=eax,ecx,edx
13=S_CURSOR
16=GetConsoleScreenBufferInfo
17=GetConsoleCursorInfo
20=.dd
23=consx/cursor/Getcursor.asm
[cursoroff]
0=void cursoroff(void);
11=consx.inc
12=eax,ecx,edx
19=SetConsoleCursorInfo
23=consx/cursor/cursoroff.asm
[cursoron]
0=void cursoron(void);
11=consx.inc
12=ecx edx
19=SetConsoleCursorInfo
23=consx/cursor/cursoron.asm
[Setcursor]
0=int Setcursor(S_CURSOR *cursor);
1=cursor
11=consx.inc
12=ecx,edx
13=S_CURSOR
18=SetConsoleCursorPosition
19=SetConsoleCursorInfo
20=.dd
23=consx/cursor/Setcursor.asm
[_wherex]
0=int _wherex(void);
8=eax x
9=edx y
11=conio.inc
12=eax,ecx,edx
19=GetConsoleScreenBufferInfo
20=.dd
21=.dd
23=conio/_wherex.asm
[_wherey]
0=int _wherey(void);
8=eax y
11=conio.inc
12=eax,ecx,edx
19=GetConsoleScreenBufferInfo
20=.dd
23=conio/_wherey.asm
[delay]
11=time.inc
12=Sleep
[dlcheckevent]
0=int dlcheckevent(void);
8=result
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/dledit.asm
[dlclose]
0=int dlclose(DOBJ *dialog);
1=dialog
8=eax: if open
9=ecx: if visible
10=edx: eax on call
11=consx.inc
12=eax,ecx,edx
13=S_DOBJ
17=dlhide
18=rcclose
19=free
20=.dd
21=.dd
22=.dd
23=consx/dobj/dlclose.asm
[dledit]
0=int dledit(char *buffer, RECT rc, int bsize, int flag);
1=buffer
2=rc
3=bsize
4=flag
8=result
11=consx.inc
12=eax,ecx,edx
13=.dd
14=S_RECT
15=.dd
16=.dd
19=timodal
20=.dd
23=consx/dobj/dledit.asm
[dlevent]
0=int dlevent(DOBJ *dialog);
1=dialog
8=result
9=edx: result
10=ecx: exit event
11=consx.inc
12=eax,ecx,edx
13=S_DOBJ
20=.dd
23=consx/dobj/dlevent.asm
[dlhide]
0=int dlhide(DOBJ *);
1=dialog
8=rchide
11=consx.inc
12=eax,ecx,edx
13=.dd
19=rchide
20=.dd
23=consx/dobj/dlhide.asm
[dlinit]
0=int dlinit(DOBJ *);
1=dialog
8=BOOL
11=consx.inc
12=eax,ecx,edx
13=.dd
15=rcalloc
16=rcread
17=dlinitobj
18=rcwrite
19=free
20=.dd
23=consx/dobj/dlinit.asm
[dllevent]
0=int dllevent(DOBJ *, LOBJ *);
1=dialog
2=list
8=result
11=consx.inc
12=eax,ecx,edx
13=S_DOBJ
14=S_LOBJ
20=.dd
23=consx/dobj/dllevent.asm
[dlmemsize]
0=int dlmemsize(DOBJ *);
1=dialog
8=memsize
11=consx.inc
12=eax,ecx,edx
13=S_DOBJ
20=.dd
23=consx/dobj/dlmemsize.asm
[dlmodal]
0=int dlmodal(DOBJ *);
1=dialog
8=result
11=consx.inc
12=eax,ecx,edx
13=S_DOBJ
18=dlevent
19=dlclose
20=.dd
23=consx/dobj/dlmodal.asm
[dlmove]
0=int dlmove(DOBJ *);
1=dialog
8=BOOL
11=consx.inc
12=eax,ecx,edx
13=.dd
18=mousep
19=rcmsmove
20=.dd
23=consx/dobj/dlmove.asm
[dlopen]
0=int dlopen(DOBJ *, char at, char *);
1=dialog
2=attrib
3=title
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
18=rcopen
23=consx/dobj/dlopen.asm
[dlpbuttevent]
0=int dlpbuttevent(void);
8=event
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/dlevent.asm
[dlradioevent]
0=int dlradioevent(void);
8=result
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/dlevent.asm
[dlscreen]
0=DOBJ *dlscreen(DOBJ *dialog, int attrib);
1=dialog
2=attrib
8=dialog
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=rcopen
20=.dd
23=consx/dobj/dlscreen.asm
[dlshow]
0=int dlshow(S_DOBJ *dialog);
1=dialog
8=BOOL
11=consx.inc
12=eax,ecx,edx
13=.dd
19=rcshow
20=.dd
23=consx/dobj/dlshow.asm
[dlteditevent]
0=int dlteditevent(void);
8=result
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/dlevent.asm
[dlxcellevent]
0=int dlxcellevent(void);
8=result
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/dlevent.asm
[oserrno]
11=errno.inc
12=DWORD
[dostounix]
0=char *dostounix(char *s1);
1=s1
8=s1
11=string.inc
12=eax
13=.dd
20=.dd
23=string/ext/dostounix.asm
[DT_BASEYEAR]
11=time.inc
12=1980
[envpath]
0=char *envpath;
11=stdlib.inc
12=DWORD
23=stdlib/GetEnvironmentPATH.asm
[envtemp]
0=char *envtemp;
11=stdlib.inc
12=DWORD
23=stdlib/GetEnvironmentTEMP.asm
[_eof]
0=int _eof(int handle);
1=handle
8=BOOL
11=io.inc
12=eax,ecx,edx
13=.dd
19=_lseek
20=.dd
23=io/_eof.asm
[ermsg]
0=int __cdecl ermsg(char *title, char *format, ...);
1=title
2=format
3=...
8=0
11=consx.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
18=ftobufin
19=msgbox
20=.dd
23=consx/msgbox/msgbox.asm
[errno]
0=int errno;
11=errno.inc
12=DWORD
[exit]
0=void exit(int return_code);
1=return_code
11=stdlib.inc
13=.dd
[fclose]
0=int fclose(FILE *);
1=FILE
8=0
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
18=fflush
19=close
20=.dd
23=stdio/fclose.asm
[fflush]
0=int fflush(FILE *fp);
1=fp
8=0
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
19=write
20=.dd
23=stdio/fflush.asm
[fgetc]
0=int fgetc(FILE *);
1=FILE
8=char
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
19=_filebuf
20=.dd
23=stdio/fgetc.asm
[fgets]
0=char *fgets(char *, int, FILE *);
1=buf
2=len
3=fp
8=buf
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=S_FILE
19=fgetc
20=.dd
23=stdio/fgets.asm
[_filelength]
0=QWORD _filelength(int handle);
1=handle
8=size
11=io.inc
12=eax,ecx,edx
13=.dd
19=GetFileSize
20=.dq
23=io/_filelength.asm
[filexist]
0=int filexist(char *file);
1=file
8=0 fail
9=1 file
10=2 directory
11=io.inc
12=eax
13=.dd
19=getfattr
20=.dd
23=io/filexist.asm
[fopen]
0=FILE *fopen(char *file, char *mode);
1=file
2=mode
8=FILE *
11=stdio.inc
12=eax,edx,ecx
13=.dd
14=.dd
18=_getst
19=sopen
20=S_FILE
23=stdio/fopen.asm
[fp_directory]
0=int (*fp_directory)(char *path);
1=path
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
20=.dd
23=direct/disk/scan_io.asm
[fp_fileblock]
0=int (*fp_fileblock)(char *path, wfblk *wf);
1=path
2=wf
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
14=S_WFBLK
20=.dd
23=direct/disk/scan_io.asm
[fp_maskp]
11=direct.inc
12=char *
23=direct/disk/scan_io.asm
[fprintf]
0=int _cdecl fprintf(FILE *, char *, ...);
1=FILE
2=format
3=VARARG
8=count
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
14=.dd
15=...
17=_stbuf
18=_output
19=_ftbuf
20=.dd
23=stdio/fprintf.asm
[fputc]
0=int fputc(int c, FILE *fp);
1=c
2=fp
8=c
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=S_FILE
19=_flsbuf
20=.dd
23=stdio/fputc.asm
[fputs]
0=int fputs(char *, FILE *);
1=cp
2=fp
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=S_FILE
20=.dd
23=stdio/fputs.asm
[fread]
0=size_t fread(void *, size_t, size_t, FILE *);
1=buf
2=num
3=size
4=fp
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=S_FILE
20=.dd
23=stdio/fread.asm
[free]
0=void free(void *block);
1=block
11=alloc.inc
12=ecx
13=.dd
23=alloc/alloc.asm
[fseek]
0=int fseek(FILE *fp, long offset, int whence);
1=fp
2=offset
3=whence
8=0
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
17=ftell
18=fflush
19=lseek
20=.dd
23=stdio/fseek.asm
[ftell]
0=int ftell(FILE *fp);
1=fp
8=offset
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
19=lseek
20=.dd
23=stdio/ftell.asm
[ftobufin]
0=int _cdecl ftobufin(char *format, ...);
1=format
2=VARARG
8=count
9=edx: _bufin
11=stdio.inc
12=eax,edx
13=.dd
14=...
18=_bufin
19=_output
20=.dd
21=.dd
23=stdio/ftobufin.asm
[fwrite]
0=size_t fwrite(void *, size_t, size_t, FILE *);
1=buf
2=num
3=size
4=fp
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=S_FILE
17=memcpy
18=fflush
19=write
20=.dd
23=stdio/fwrite.asm
[_getch]
0=int _getch(void);
8=char
11=conio.inc
12=eax,ecx,edx
20=.dd
23=conio/getch.asm
[getcomspec]
0=char *getcomspec(void);
8=comspec
11=stdlib.inc
12=eax,ecx,edx
14=filexist
15=free
16=salloc
17=inientry
18=expenviron
19=strncpy
20=.dd
23=process/comspec.asm
[_getcwd]
0=char *_getcwd(char *buf, int maxlen);
1=buf
2=maxlen
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
16=_getdcwd
20=.dd
23=direct/_getcwd.asm
[_getdcwd]
0=char *_getdcwd(char *buf, int drv, int maxlen);
1=buf
2=drv
3=maxlen
8=buf
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=validdrive
17=GetFullPathName
18=GetCurrentDirectory
19=malloc
20=.dd
23=direct/_getdcwd.asm
[_getdrive]
0=int _getdrive(void);
8=drive
11=direct.inc
12=eax,ecx,edx
19=GetCurrentDirectory
20=.dd
23=direct/_gerdrive.asm
[getenv]
0=char *getenv(char *enval);
1=enval
8=*_environ[x]
11=stdlib.inc
12=eax ecx
13=.dd
17=_environ
18=strlen
19=strnicmp
20=.dd
23=stdlib/getenv.asm
[getenvp]
0=char *getenvp(char *enval);
1=enval
8=new string
11=stdlib.inc
12=eax
13=.dd
17=GetEnvironmentVariable
18=malloc
19=strcpy
20=.dd
23=stdlib/getenvp.asm
[getevent]
0=int getevent(void);
8=result
11=consx.inc
12=eax,ecx,edx
20=.dd
23=consx/dobj/getevent.asm
[GetFileSystemName]
0=int GetFileSystemName(char *lpRootPathName, char *lpFileSystemNameBuffer);
1=lpRootPathName
2=lpFileSystemNameBuffer
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=GetVolumeInformation
20=.dd
23=direct/disk/GetFileSystemName.asm
[getftime]
0=int getftime(int handle);
1=handle
8=time
11=io.inc
12=eax
13=.dd
17=getosfhnd
18=GetFileTime
19=FileTimeToTime
20=.dd
23=io/ext/getftime.asm
[getftime_access]
0=int getftime_access(int handle);
1=handle
8=time
11=io.inc
12=eax
13=.dd
17=getosfhnd
18=GetFileTime
19=FileTimeToTime
20=.dd
23=io/ext/getftime_access.asm
[getftime_create]
0=int getftime_create(int handle);
1=handle
8=time
11=io.inc
12=eax
13=.dd
17=getosfhnd
18=GetFileTime
19=FileTimeToTime
20=.dd
23=io/ext/getftime_create.asm
[getkey]
0=int getkey(void);
8=key
11=keyb.inc
12=eax,ecx,edx
15=ReadEvevnt
16=popkey
20=.dd
23=consx/keyb/getkey.asm
[getosfhnd]
0=int getosfhnd(int handle);
1=handle
8=os-handle
11=io.inc
12=eax,ecx
13=.dd
20=.dd
23=io/getosfhnd.asm
[GetSSELevel]
0=int GetSSELevel(void)
8=sselevel
11=math.inc
12=eax ecx edx
20=.dd
23=ctrl/sselevel.asm
[GetVolumeID]
0=int GetVolumeID(char *lpRootPathName, char *lpVolumeNameBuffer);
1=lpRootPathName
2=lpVolumeNameBuffer
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=GetVolumeInformation
20=.dd
23=direct/disk/GetVolumeID.asm
[getxya]
0=int getxya(int x, int y);
1=x
2=y
8=attrib
11=consx.inc
12=eax
13=.dd
14=.dd
19=ReadConsoleOutputAttribute
20=.dd
23=consx/cout/getxya.asm
[getxyc]
0=int getxyc(int x, int y);
1=x
2=y
8=char
11=consx.inc
12=eax
13=.dd
14=.dd
20=.dd
23=consx/cout/getxyc.asm
[getxys]
0=int getxys(int x, int y, char *b, int lsize, int bsize);
1=x
2=y
3=b
4=lsize
5=bsize
8=result
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=.dd
17=.dd
19=dledit
20=.dd
23=consx/cout/getxys.asm
[getxyw]
0=int getxyw(int x, int y);
1=x
2=y
8=ah = attrib
9=al = char
11=consx.inc
12=eax
13=.dd
14=.dd
18=getxya
19=getxyc
20=.db
21=.db
23=consx/cout/getxyw.asm
[_gotoxy]
0=void _gotoxy(int x, int y);
1=x
2=y
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
16=SetConsoleCursorPosition
23=conio/_gotoxy.asm
[hStdError]
11=io.inc
12=DWORD
23=io/_ioinit.asm
[hStdInput]
11=io.inc
12=DWORD
23=io/_ioinit.asm
[hStdOutput]
11=io.inc
12=DWORD
23=io/_ioinit.asm
[iniclose]
0=int iniclose(void);
8=0
11=ini.inc
13=free
20=.dd
23=ini/iniopen.asm
[inicommand]
0=char *inicommand(char *string, char *file, char *section);
1=string
2=file
3=section
8=string
11=process.inc
12=eax ecx edx
13=.dd
14=.dd
15=.dd
20=.dd
23=process/inicommand.asm
[inientry]
0=char *inientry(char *section, char *entry);
1=section
2=entry
8=value
11=ini.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=ini/inientry.asm
[inientryf]
11=ini.inc
23=ini/inientryf.asm
[inientryid]
0=char *inientryid(char *section, int entry);
1=section
2=endtry
8=value
11=ini.inc
12=eax,ecx
13=.dd
14=.dd
16=inientry
20=.dd
23=ini/ientryid.asm
[inierror]
0=int inierror(char *section, char *entry);
8=0
11=ini.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=ermsg
20=.dd
23=ini/inierror.asm
[iniopen]
0=char *iniopen(char *file);
1=file
8=salloc(file)
11=ini.inc
12=eax,ecx
13=.dd
15=osopen
16=filelength
17=malloc
18=close
20=.dd
23=ini/iniopen.asm
[ioclose]
0=void ioclose(IOST *);
1=IOST
11=iost.inc
12=ecx,edx
13=S_IOST
18=close
19=iofree
23=iost/ioclose.asm
[iocopy]
0=int iocopy(IOST *des, IOST *src, long len);
1=des
2=src
3=len
8=BOOL
11=iost.inc
12=eax,ecx,edx
13=S_IOST
14=S_IOST
15=.dq
16=iogetc
17=ioputc
18=ioflush
19=iofread
20=.dd
23=iost/iocopy.asm
[ioflush]
0=int ioflush(IOST *);
1=IOST
8=BOOL
11=iost.inc
12=eax,ecx
13=S_IOST
16=ioswrite
17=oupdate
18=oupdcrc
19=ClipboardCopy
20=.dd
23=iost/ioflush.asm
[iofree]
0=void iofree(IOST *);
1=IOST
11=iost.inc
12=ecx
13=S_IOST
19=free
23=iost/iofree.asm
[iogetc]
0=int _fastcall iogetc(IOST *);
1=IOST
8=char
11=iost.inc
12=eax
13=S_IOST
19=iofread
20=.dd
23=iost/iogetc.asm
[ioinit]
0=void *ioinit(IOST *stream, int bsize);
1=stream
2=bsize
3= -1
6= < 10
8=.ios_bp
11=iost.inc
12=eax,edx,ecx
13=S_IOST
14=.dd
15=allocseg
16=malloc
17=memzero
18=iofread
19=filelength
20=.dd
23=iost/ioinit.asm
[ioopen]
0=int ioopen(IOST *io, char *file, int mode, int bsize);
1=io
2=file
3=mode
4=bsize
8=handle
11=iost.inc
12=eax,ecx,edx
13=S_IOST
14=.dd
15=.dd
16=.dd
17=osopen
18=openfile
19=ioinit
20=.dd
23=iost/ioopen.asm
[ioputc]
0=int _fastcall ioputc(int c, IOST *);
1=c
2=IOST
8=BOOL
11=iost.inc
12=eax
13=.dd
14=S_IOST
20=.dd
23=iost/ioputc.asm
[ioread]
0=int ioread(IOST *);
1=IOST
7=__ZIP__
8=BOOL
11=iost.inc
12=eax ecx
13=S_IOST
15=osread
16=oupdcrc
17=oupdate
18=memcpy
19=odecrypt
20=.dd
23=iost/ioread.asm
[ioseek]
0=int ioseek(IOST *io, DWORD offset, int from);
1=io
2=offset
3=from
8=offset
9=ZF set on error..
11=iost.inc
12=eax,ecx,edx
13=S_IOST
14=.dd
15=.dd
19=lseek
20=.dd
23=iost/ioseek.asm
[IOST]
11=iost.inc
12=STRUCT
[iotell]
0=int iotell(IOST *);
1=IOST
8=offset
11=iost.inc
12=eax
13=S_IOST
20=.dd
23=iost/otellst.asm
[iowrite]
0=int iowrite(IOST *, void *buf, int len);
1=IOST
2=buf
3=len
8=&buf[len]
11=iost.inc
12=eax,ecx,edx
13=S_IOST
14=.dd
15=.dd
19=ioputc
20=.dd
23=iost/iowrite.asm
[isascii]
0=al
7=ZF
11=ctype.inc
13=.n
23=isascii.asm
[_isatty]
0=int _isatty(int handle);
1=handle
8=BOOL
11=io.inc
12=eax
13=.dd
20=.dd
23=io/_isatty.asm
[__isexec]
0=int _fastcall __isexec(char *file);
1=file (eax)
8=0,1=bat,2=com,3=exe
11=ctrl.inc
12=eax,ecx
13=.dd
15=strrchr
20=.dd
23=crtl/__isexec.asm
[_kbhit]
0=int _kbhit(void);
8=key
11=conio.inc
12=eax,ecx,edx
20=.dd
23=conio/_kbhit.asm
[_lseek]
0=DWORD _lseek(int handle, DWORD offset, int from);
1=handle
2=offset
3=from
8=offset
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
18=getosfhnd
19=SetFilePointer
20=.dd
23=io/_lseek.asm
[malloc]
0=void *malloc(int size);
1=size
8=void *
11=alloc.inc
12=eax,ecx,edx
13=.dd
20=.dd
23=alloc/alloc.asm
[memchr]
0=void *memchr(char *, int, len);
1=base
2=char
3=length
8=address of char
9=ZERO flag set
11=string.inc
12=eax ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/memchr.asm
[memcmp]
0=int memcmp(char *s1, char *s2, int len);
1=s1
2=s2
3=len
8=eax
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/memcmp.asm
[memcpy]
0=void *memcpy(void *des, void *src, size_t len);
1=des
2=src
3=len
8=des
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/memcpy.asm
[memmove]
0=void *memmove(void *des, void *src, int count)
1=des
2=src
3=count
8=des
11=string.inc
12=eax ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/memmove.asm
[memquote]
0=char *memquote(char *);
1=string
8=pointer to ' or "
11=string.inc
12=eax ecx
13=.dd
20=.dd
23=string/ext/memquote.asm
[memset]
0=void *memset(void *src, int ch, int len);
1=src
2=ch
3=len
8=src
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/memset.asm
[memstri]
0=char *memstri(char *, int, char *, int);
1=s1
2=len
3=s2
4=len
8=eax ptr to s2 in s1
11=string.inc
12=eax, ecx
13=.dd
14=.dd
15=.dd
16=.dd
20=.dd
23=string/ext/memstri.asm
[memxchg]
0=void *memxchg(void *des, void *src, int len);
1=des
2=src
3=len
8=des
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/ext/memxchg.asm
[memzero]
0=void *memzero(void *string, int count);
1=string
2=count
8=string
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/ext/memzero.asm
[mkbstring]
0=int mkbstring(char *buf, __int64 value);
1=buf
2=value
8=?
11=stdlib.inc
12=eax,ecx,edx
13=.dd
14=.dq
18=sprintf
19=strrev
20=.dd
23=string/ext/mkbstring.asm
[_mkdir]
0=int _mkdir(char *directory)
1=directory
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
19=CreateDirectory
20=.dd
23=direct/_mkdir.asm
[_mkdirw]
0=int _mkdirw(WORD *directory)
1=directory
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
19=CreateDirectory
20=.dd
23=direct/_mkdirw.asm
[mousep]
0=int mousep(void);
8=0,1,2,3
11=keyb.inc
12=eax
20=.dd
23=consx/keyb/mousep.asm
[mousewait]
0=void mousewait(int x, int y, int length)
1=x
2=y
3=length
11=mouse.inc
12=eax,edx
13=.dd
14=.dd
15=.dd
17=mousep
18=mousex
19=mousey
23=consx/keyb/mousewait.asm
[mousex]
0=int mousex(void);
8=mouse_current_x
11=keyb.inc
12=eax
20=.dd
23=consx/keyb/mousex.asm
[mousey]
0=int mousey(void);
8=mouse_current_y
11=keyb.inc
12=eax
20=.dd
23=consx/keyb/mousey.asm
[msgbox]
0=void msgbox(char *name, int flag, char *string);
1=name
2=flag
3=string
8=?
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
18=strchr
19=strlen
20=.dd
23=consx/msgbox/msgbox.asm
[msloop]
0=void msloop(void);
8=0
11=keyb.inc
12=eax
13=mousep
20=.dd
23=consx/keyb/msloop.asm
[notsup]
0=int notsup(void);
8=0
11=errno.inc
12=eax,ecx,edx
19=ermsg
20=.dd
23=consx/msgbox/notsup.asm
[ogetc]
0=int ogetc(void);
8=char
11=iost.inc
12=eax
19=iogetc
20=.dd
23=iost/iogetc.asm
[ogetl]
0=int ogetl(char *file, void *buf, int bsize);
1=file
2=buf
3=bsize
8=BOOL
11=iost.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
19=ioopen
20=.dd
23=iost/ogets.asm
[ogetouth]
0=int ogetouth(char *file, int mode);
1=file
2=mode
8=handle
11=iost.inc
12=eax,ecx,edx
13=.dd
14=.dd
17=osopen
18=setfattr
19=openfile
20=.dd
23=iost/ogetouth.asm
[ogets]
0=char *ogets(void);
8=line
11=iost.inc
12=eax,ecx
19=ogetc
20=.dd
23=iost/ogets.asm
[_open]
0=int _cdecl _open(char *path, int oflag, ...);
1=path
2=oflag
3=VARARG
8=handle
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
19=sopen
20=.dd
23=io/_open.asm
[openfile]
0=int openfile(char *file, int mode, int action);
1=file
2=mode
3=action
8=handle
11=iost.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
19=osopen
20=.dd
23=iost/openfile.asm
[oprintf]
0=int _cdecl oprintf(char *format, ...);
1=format
2=VARARG
4=uses FH_TEXT: 0Dh
8=count
11=iost.inc
12=eax,ecx,edx
13=.dd
14=.dd
16=STDO
18=ftobufin
19=oputc
20=.dd
23=iost/oprintf.asm
[oputc]
0=int _fastcall oputc(int c);
1=c
8=BOOL
11=iost.inc
12=eax
13=.dd
19=oputcst
20=.dd
23=iost/oputc.asm
[oputs]
0=int oputs(char *line);
1=line
8=BOOL
11=iost.inc
12=eax
13=.dd
19=oputc
20=.dd
23=iost/oputs.asm
[oread]
0=void * _fastcall oread(int size)
1=size
8=void *
9=ecx bsize
11=iost.inc
12=eax,ecx
13=.dd
19=ofread
20=.dd
21=.dd
23=iost/oread.asm
[oreadb]
0=int oreadb(void *buf, int len);
1=buf
2=len
8=count
11=iost.inc
12=eax
13=.dd
14=.dd
17=oread
18=ogetc
19=memcpy
20=.dd
23=iost/oreadb.asm
[osearch]
0=int osearch(void);
8=BOOL
11=iost.inc
12=eax,ecx,edx
17=memsearch
18=searchhex
19=searchtxt
20=.dd
23=iost/osearch.asm
[oseek]
0=int oseek(DWORD offset, int from);
1=offset
2=from
8=BOOL?
11=iost.inc
12=eax,ecx,edx
13=.dd
14=.dd
18=oseekst
19=ofread
20=.dd
23=iost/oseek.asm
[osfiletype]
0=int osfiletype(int handle);
1=handle
8=type
11=io.inc
12=eax,ecx,edx
13=.dd
19=GetFileType
20=.dd
23=io/ext/osfiletype.asm
[osmaperr]
0=int osmaperr(void);
8=-1
9=edx: oserror
11=errno.inc
12=eax,ecx,edx
19=GetLastError
20=.dd
23=errno/osmaperr.asm
[osopen]
0=int osopen(name, attrib, mode, action)
1=name
2=attrib
3=mode
4=action
8=handle
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=.dd
19=CreateFile
20=.dd
23=io/osopen.asm
[osread]
0=int osread(int handle, void *buffer, int count);
1=handle
2=buffer
3=count
8=count
11=io.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=io/osread.asm
[oswrite]
0=int oswrite(int handle, void *buf, int size);
1=handle
2=buffer
3=size
8=count
11=io.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
19=WriteFile
20=.dd
23=io/oswrite.asm
[oungetc]
0=int oungetc(void);
8=char
11=iost.inc
12=eax,edx,ecx
18=lseek
19=oseek
20=.dd
23=iost/oungetc.asm
[oupdcrc]
0=int oupdcrc(void);
1=esi
2=eax
8=CRC (.ios_bb)
11=iost.inc
12=ecx,edx -- inline
13=S_IOST
14=count
20=.dd
23=iost/oupdcrc.asm
[perror]
0=void perror(char *);
1=msg
11=stdio.inc
12=eax,ecx,edx
13=.dd
18=strlen
19=write
23=stdio/perror.asm
[pGetForegroundWindow]
0=int (*pGetForegroundWindow)(void);
1=ifdef __WIN95__
8=handle
11=stdlib.inc
12=eax ecx edx
20=.dd
23=consx/console/pGetForegroundWindow.asm
[popkey]
0=int popkey(void);
8=eax key
9=edx keyshift
11=keyb.inc
12=eax,edx
15=pushkey
20=.dd
21=.dd
23=consx/keyb/pushkey.asm
[printf]
0=int _cdecl printf(char *, ...);
1=format
2=VARARG
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
14=...
17=_stbuf
18=_output
19=_ftbuf
20=.dd
23=stdio/printf.asm
[process]
0=int process(char *program, char *command, int flag);
1=program
2=command
3=flag
6=global:
7=errorlevel
8=BOOL
11=process.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
17=system
19=.dd
20=.dd
23=process/process.asm
[pushkey]
0=int pushkey(int key);
1=key
8=key
11=keyb.inc
12=ecx
13=.dd
15=popkey
20=.dd
23=consx/keyb/pushkey.asm
[_putch]
0=int _putch(char ch);
1=ch
8=1
11=conio.inc
12=eax,ecx,edx
13=.db
19=write
20=.dd
23=conio/_putch.asm
[puts]
0=int puts(char *);
1=cp
8=count
11=stdio.inc
12=eax,ecx,edx
13=.dd
18=strlen
19=write
20=.dd
23=stdio/puts.asm
[qsort]
0=void qsort(void *p, int n, int w, int (*compare)(void *, void *));
11=stdlib.inc
12=eax ecx edx
23=stdlib/qsort.asm
[rcaddrc]
0=RECT rcaddrc(RECT *, RECT, RECT);
1=rc
2=r1
3=r1
8=rc
11=consx.inc
12=eax
13=S_RECT
14=S_RECT
15=S_RECT
20=S_RECT
23=consx/rect/rcaddrc.asm
[rcalloc]
0=void *rcalloc(RECT, int);
1=rc
2=shade
8=void *
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
18=rcmemsize
19=malloc
20=.dd
23=consx/rect/rcalloc.asm
[rcbprc]
0=void *rcbprc(RECT, void *, int dlcols);
1=rc
2=buf
3=col
8=word *
11=consx.inc
12=eax
13=S_RECT
14=.dd
15=.dd
20=.dd
23=consx/rect/rcbprc.asm
[rcbprcrc]
0=void *rcbprcrc(RECT, RECT, void *, int dlcols);
1=r1
2=r2
3=buf
4=col
8=word *
11=consx.inc
12=eax
13=S_RECT
14=S_RECT
15=.dd
16=.dd
20=.dd
23=consx/rect/rcbprcrc.asm
[rcclose]
0=int rcclose(RECT, int, void *);
1=rc
2=flag
3=wp
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
18=rchide
19=free
20=.dd
23=consx/rect/rcclose.asm
[rcclrshade]
0=void rcclrshade(RECT, void *);
1=rc
2=wp
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
23=consx/rect/rcshade.asm
[rcframe]
0=void rcframe(RECT, void *, int lsize, int type_color);
1=rc
2=wp
3=lsize
4=ftype
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
23=consx/rect/rcframe.asm
[rchide]
0=int rchide(RECT, int, void *);
1=rc
2=flag
3=wp
11=consx.inc
12=eax,edx,ecx
13=S_RECT
14=.dd
15=.dd
18=rcxchg
19=rcclrshade
23=consx/rect/rchide.asm
[rcinside]
0=int rcinside(RECT dlg, RECT obj);
1=r1
2=r2
8=line 1..max
11=consx.inc
12=eax,edx,ecx
13=S_RECT
14=S_RECT
20=.dd
23=consx/rect/rcinside.asm
[rcmemsize]
0=int rcmemsize(RECT, int);
1=rc
2=flag
8=memsize
11=consx.inc
12=eax
13=S_RECT
14=.dd
20=.dd
23=consx/rect/rcmemsize.asm
[rcmove]
0=RECT rcmove(RECT *, void *, int, int, int);
1=rc
2=wp
3=flag
4=x
5=y
8=rc
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=S_WCHAR
15=.dd
16=.dd
17=.dd
18=rchide
19=rcshow
20=S_RECT
23=consx/rect/rcmove.asm
[rcmovedn]
0=RECT rcmovedn(RECT rc, void *wp, int flag);
1=rc
2=wp
3=flag
8=RECT
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
17=rcalloc
18=rchide
19=rcshow
20=.dd
23=consx/rect/rcmovems.asm
[rcmoveleft]
0=RECT rcmoveleft(RECT rc, void *wp, int flag);
1=rc
2=wp
3=flag
8=RECT
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
17=rcalloc
18=rchide
19=rcshow
20=.dd
23=consx/rect/rcmovems.asm
[rcmoveright]
0=RECT rcmoveright(RECT rc, void *wp, int flag);
1=rc
2=wp
3=flag
8=RECT
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
17=rcalloc
18=rchide
19=rcshow
20=.dd
23=consx/rect/rcmovems.asm
[rcmoveup]
0=RECT rcmoveup(RECT rc, void *wp, int flag);
1=rc
2=wp
3=flag
8=RECT
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
17=rcalloc
18=rchide
19=rcshow
20=.dd
23=consx/rect/rcmovems.asm
[rcmsmove]
0=RECT rcmsmove(RECT *, void *, int);
1=rp
2=wp
3=flag
8=rc
11=consx.inc
12=eax,edx,ecx
13=S_RECT
14=.dd
15=.dd
16=rcclrshade
17=mousey
18=mousex
19=rcsetshade
20=S_RECT
23=consx/rect/rcmsmove.asm
[rcopen]
0=void *rcopen(RECT, int, char, char *, void *);
1=rc
2=flag
3=attrib
4=title
5=wp
8=wp
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
16=.dd
17=.dd
19=rcalloc
20=.dd
23=consx/rect/rcopen.asm
[rcpush]
0=void *rcpush(int lines);
1=lines
8=void *
11=consx.inc
12=eax,ecx,edx
13=.dd
19=rcopen
20=.dd
23=consx/rect/rcpush.asm
[rcread]
0=void rcread(RECT, void *);
1=rc
2=wp
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
17=malloc
18=free
19=ReadConsoleOutput
23=consx/rect/rcread.asm
[rcsetshade]
0=void rcsetshade(RECT, void *);
1=rc
2=wp
11=consx.inc
12=eax
13=.dd
14=.dd
23=consx/rect/rcshade.asm
[rcshow]
0=int rcshow(S_RECT rc, int flag, void *wp);
1=rc
2=flag
3=wp
8=BOOL is open
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
15=.dd
18=rcxchg
19=rcsetshade
20=.dd
23=consx/rect/rcshow.asm
[rcwrite]
0=void rcwrite(RECT, void *);
1=rc
2=wp
11=consx.inc
12=eax,ecx,edx
13=S_RECT
14=.dd
17=malloc
18=free
19=ReadConsoleOutput
23=consx/rect/rcwrite.asm
[rcxchg]
0=void rcxchg(RECT, void *);
1=rc
2=buf
11=consx.inc
12=eax,edx
13=S_RECT
14=.dd
17=malloc
18=rcreadc
19=WriteConsoleOutput
23=consx/rect/rcxchg.asm
[rcxyrow]
0=int rcxyrow(RECT, int, int);
1=rc
2=x
3=y
8=row
11=consx.inc
12=eax
13=S_RECT
14=.dd
15=.dd
20=.dd
23=consx/rect/rcxyrow.asm
[_read]
0=int _read(int handle, void *buffer, int size);
1=handle
2=buffer
3=size
8=count
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
17=osread
20=.dd
23=io/_read.asm
[readword]
0=DWORD readword(char *file);
1=file
8=dword
11=io.inc
12=eax,ecx,edx
13=.dd
17=osopen
18=osread
19=close
20=.dd
23=io/ext/readword.asm
[recursive]
0=int recursive(char *file, char *path, char *dest);
1=file
2=path
3=dest
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=strfcat
17=strcpy
18=strfn
19=strnicmp
20=.dd
23=direct/disk/recursive.asm
[remove]
0=int remove(char *file);
1=file
8=0
11=io.inc
12=eax,ecx,edx
13=.dd
19=DeleteFile
20=.dd
23=io/remove.asm
[rename]
0=int rename(char *old_name, char *new_name);
1=old
2=new
8=0
11=io.inc
12=eax,edx,ecx
13=.dd
14=.dd
20=.dd
23=io/rename.asm
[_rmdir]
0=int _rmdir(char *directory);
1=directory
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
19=RemoveDirectory
20=.dd
23=dir/_rmdir.asm
[rsevent]
0=int rsevent(void *, DOBJ *);
1=rs
2=dl
8=result
11=consx.inc
12=eax,ecx,edx
13=S_ROBJ
14=S_DOBJ
19=dlevent
20=.dd
23=consx/robj/rsevent.asm
[rsmodal]
0=int rsmodal(void *);
1=IDD
8=result
11=consx.inc
12=eax,edx,ecx
13=S_ROBJ
17=rsopen
18=rsevent
19=dlclose
20=.dd
23=consx/robj/rsmodal.asm
[rsopen]
0=DOBJ *rsopen(ROBJ *);
1=idd
8=S_DOBJ *dialog
11=consx.inc
12=eax
13=S_ROBJ
15=S_DOBJ
18=rsunzipch
19=rsunzipat
20=.dd
23=consx/robj/rsopen.asm
[rsreload]
0=int rsreload(void *, DOBJ *);
1=rs
2=dl
8=BOOL
11=consx.inc
12=eax,ecx,edx
13=S_ROBJ
14=S_DOBJ
16=dlhide
17=wcunzip
18=dlinit
19=dlshow
20=.dd
23=consx/robj/rsreload.asm
[rsunzipat]
11=consx.inc
12=eax,ecx,edx,esi,edi
23=consx/robj/rsunzipa.asm
[rsunzipch]
11=consx.inc
12=eax,ecx,edx,esi,edi
23=consx/robj/rsunzipc.asm
[S_COLOR]
1=cl_backgr[16]
2=cl_foregr[16]
3=cl_palett[16]
11=consx.inc
12=BYTE[8+16+16]
13=.s
14=.db
15=.db
16=.db
[S_CURSOR]
1=dwSize
2=bVisible
3=x
4=y
11=consx.inc
12=STRUCT
13=.dd
14=.dd
15=.dw
16=.dw
[S_DOBJ]
1=dl_flag
2=dl_count
3=dl_index
4=dl_rect
5=dl_object
6=dl_wp
11=consx.inc
12=STRUCT
13=.dw
14=.db
15=.db
16=.dd
17=.dd
18=.dd
[S_FBLK]
11=fblk.inc
12=STRUCT
[S_FILE]
11=stdio.inc
12=STRUCT
[S_FTIME]
1=ft_low
2=ft_high
11=time.inc
12=STRUCT QWORD
13=.dd
14=.dd
16=FILETIME
[S_IOST]
1=ios_bp
2=ios_i
3=ios_c
4=ios_size
5=ios_flag
6=ios_file
7=ios_l
8=ios_bb
9=ios_total
10=ios_offset
11=iost.inc
12=STRUCT
13=.dd
14=.dd
15=.dd
16=.dd
17=.dd
18=.dd
19=.dd
20=.dd
21=.dq
22=.dd
[S_LOBJ]
11=consx.inc
12=STRUCT
[S_PATH]
11=wsub.inc
12=STRUCT
[S_RECT]
1=rc_x
2=rc_y
3=rc_col
4=rc_row
11=consx.inc
12=STRUCT
13=.db
14=.db
15=.db
16=.db
[S_ROBJ]
11=consx.inc
12=STRUCT
13=S_RECT
[S_STIME]
11=time.inc
12=STRUCT SYSTEMTIME
[S_TINFO]
11=tinfo.inc
12=STRUCT
[S_TOBJ]
1=to_flag
2=to_count
3=to_ascii
4=to_rect
5=to_data
6=to_proc
11=consx.inc
12=STRUCT
13=.dw
14=.db
15=.db
16=S_RECT
17=.dd
18=.dd
[S_WCHAR]
1=wc_ch
2=wc_at
11=consx.inc
12=STRUCT
13=.db
14=.db
[S_WFBLK]
1=wf_attrib
2=wf_timecreate
3=wf_timeaccess
4=wf_time
5=wf_size
6=wf_reserved[8]
7=wf_name[260]
8=wf_shortname[14]
11=dos.inc
12=STRUCT
13=.dd
14=.dq
15=.dq
16=.dq
17=.dq
18=.db
19=.db
20=.db
[S_WSUB]
11=wsub.inc
12=STRUCT
13=S_PATH
[salloc]
0=void *salloc(char *s1);
1=s1
8=void *
11=alloc.inc
12=eax edx ecx
13=.dd
15=strlen
16=malloc
20=.dd
23=alloc/salloc.asm
[SaveEnvironment]
0=BOOL SaveEnvironment(const char *);
1=FileName
8=BOOL
11=stdlib.inc
12=eax ecx edx
13=.dd
20=.dd
23=stdlib/SaveEnvironment.asm
[scan_directory]
0=int scan_directory(int flag, char *path);
1=flag
2=path
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=fp_directory
16=strlen
17=strfcat
18=wfindfirst
19=wfindnext
20=.dd
23=direct/disk/scan_io.asm
[scan_files]
0=int scan_files(char *path);
1=path
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
16=strfcat
17=wfindfirst
18=wfindnext
19=wcloseff
20=.dd
23=direct/disk/scan_io.asm
[scansub]
0=int scansub(char *path, char *mask, int flag);
1=path
2=mask
3=flag
8=0
11=direct.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
20=.dd
23=direct/disk/scan_io.asm
[scenter]
0=int scenter(int, int, int, char *);
1=x
2=y
3=l
4=cp
8=count
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
18=strlen
19=scputs
20=.dd
23=consx/cout/scenter.asm
[scgetws]
0=void *scgetws(int x, int y, int l);
1=x
2=y
3=l
8=void *
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
18=malloc
19=ReadConsoleOutput
20=.dd
23=consx/cout/scgetws.asm
[scpath]
0=int scpath(int, int, int l, char *);
1=x
2=y
3=l
4=string
8=count
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
17=strcpy
18=strlen
19=scputs
20=.dd
23=consx/cout/scpath.asm
[scpop]
0=void scpop(void *buf, int lcount);
1=buf
2=lcount
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=rcclose
23=consx/cout/scpush.asm
[scpush]
0=void *scpush(int lcount);
1=lcount (* 80)
8=void *
11=consx.inc
12=eax,ecx,edx
13=.dd
19=rcopen
20=.dd
23=consx/cout/scpush.asm
[scputa]
0=void scputa(int x, int y, int l, int at);
1=x
2=y
3=l
4=at
11=consx.inc
13=.dd
14=.dd
15=.dd
16=.dd
19=FillConsoleOutputAttribute
23=consx/cout/scputa.asm
[scputbg]
0=void scputbg(int x, int y, int l, int at);
1=x
2=y
3=l
4=at
11=consx.inc
13=.dd
14=.dd
15=.dd
16=.dd
23=consx/cout/scputbg.asm
[scputc]
0=void scputc(int, int, int l, int ch);
1=x
2=y
3=l
4=ch
11=consx.inc
13=.dd
14=.dd
15=.dd
16=.dd
19=FillConsoleOutputCharacter
23=consx/cout/scputc.asm
[scputf]
0=int _cdecl scputf(int, int, int at, int max, char *, ...);
1=x
2=y
3=a
4=max
5=format
6=...
8=count
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
17=.dd
18=ftobufin
19=scputs
20=.dd
23=consx/cout/scputf.asm
[scputfg]
0=void scputfg(int x, int y, int l, int at);
1=x
2=y
3=l
4=at
11=consx.inc
13=.dd
14=.dd
15=.dd
16=.dd
23=consx/cout/scputfg.asm
[scputs]
0=int scputs(int, int, int at, int max, char *);
1=x
2=y
3=at
4=max
5=string
8=count
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
17=.dd
20=.dd
23=consx/cout/scputs.asm
[scputw]
0=void scputw(int, int, int l, int w);
1=x
2=y
3=l
4=w
11=consx.inc
13=.dd
14=.dd
15=.dd
16=.dd
18=scputa
19=scputc
23=consx/cout/scputw.asm
[scputws]
0=void scputws(int, int, int, void *);
1=x
2=y
3=l
4=wp
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
18=free
19=WriteConsoleOutput
23=consx/cout/scputws.asm
[scroll_delay]
0=void scroll_delay(void);
11=consx.inc
12=eax,ecx,edx
18=tupdate
19=delay
23=consx/dobj/scroll_delay.asm
[searchp]
0=char *searchp(char *file);
1=file
8=char *
11=stdlib.inc
12=eax,ecx,edx
13=.dd
15=filexist
16=strfcat
17=getcwd
18=strlen
19=strcpy
20=.dd
23=stdlib/searchp.asm
[SEEK_CUR]
11=io.inc
12=1
[SEEK_END]
11=io.inc
12=2
[SEEK_SET]
11=io.inc
12=0
[setargv]
0=void setargv(int *argc, char ***argv, char *cmdline);
1=argc
2=argv
3=cmdline
11=stdlib.inc
12=eax ecx edx
13=.dd
14=.dd
15=.dd
23=stdlib/setargv.asm
[setbuf]
0=void setbuf(FILE *fp, char *buf);
1=fp
2=buf
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
14=.dd
19=setvbuf
23=stdio/setbuf.asm
[setfattr]
0=int setfattr(char *file, int attrib);
1=file
2=attrib
8=0
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
19=SetFileAttributes
20=.dd
23=io/ext/setfattr.asm
[setfext]
0=char *setfext(char *path, char *ext);
1=path
2=ext
8=path
11=string.inc
12=eax,ecx
13=.dd
14=.dd
16=strcat
17=strext
20=.dd
23=string/ext/setfext.asm
[setftime]
0=int setftime(int handle, int time);
1=handle
2=time
8=0,-1 = fail
11=io.inc
12=eax
13=.dd
14=.dd
17=getosfhnd
18=TimeToFileTime
19=SetFileTime
20=.dd
23=io/ext/setftime.asm
[setftime_access]
0=int setftime_access(int handle, int time);
1=handle
2=time
8=0,-1 = fail
11=io.inc
12=eax
13=.dd
14=.dd
17=getosfhnd
18=TimeToFileTime
19=SetFileTime
20=.dd
23=io/ext/setftime_access.asm
[setftime_create]
0=int setftime_create(int handle, int time);
1=handle
2=time
8=0,-1 = fail
11=io.inc
12=eax
13=.dd
14=.dd
17=getosfhnd
18=TimeToFileTime
19=SetFileTime
20=.dd
23=io/ext/setftime_create.asm
[SetKeyState]
0=void SetKeyState(void);
11=keyb.inc
12=edx,ecx
23=consx/keyb/SetKeyState.asm
[setvbuf]
0=void setvbuf(FILE *, char *buf, int type, size_t size);
1=fp
2=buf
3=type
4=size
11=stdio.inc
12=eax,ecx,edx
13=S_FILE
14=.dd
15=.dd
16=.dd
17=fflush
18=_freebuf
19=malloc
23=stdio/setvbuf.asm
[_sopen]
0=int _cdecl _sopen(char *path, int oflag, int shflag, ...);
1=path
2=oflag
3=shflag
4=VARARG
8=handle
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=.dd
18=CreateFile
19=GetFileType
20=.dd
23=io/_sopen.asm
[sprintf]
0=int __cdecl sprintf(char *string, char *format, ...);
1=string
2=format
3=VARARG
8=count
11=stdio.inc
12=eax
13=.dd
14=.dd
15=.dd
19=_output
20=.dd
23=stdio/sprintf.asm
[stderr]
11=stdio.inc
12=_iob[2]
23=stdio/_file.asm
[STDI]
11=iost.inc
12=in stream
13=.s
14=S_IOST
23=iost/iost.asm
[stdmsg]
0=int __cdecl stdmsg(char *title, char *format, ...);
1=title
2=format
3=...
8=0
11=consx.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
18=ftobufin
19=msgbox
20=.dd
23=consx/msgbox/msgbox.asm
[STDO]
11=iost.inc
12=out stream
13=.s
14=S_IOST
23=iost/iost.asm
[stdout]
11=stdio.inc
12=_iob[1]
23=stdio/_file.asm
[strcat]
0=char *strcat(char *s1, char *s2);
1=s1
2=s2
8=s1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/strcat.asm
[strchr]
0=char *strchr(char *string, int char)
1=string
2=char
8=char *
11=string.inc
12=eax ecx
13=.dd
14=.dd
20=.dd
23=string/strchr.asm
[strcmp]
0=char *strcmp(char *s1, char *s2);
1=s1
2=s2
8=s1
11=string.inc
12=eax ecx
13=.dd
14=.dd
20=.dd
23=string/strcmp.asm
[strcmpi]
1=edx=esi on call
2=ecx=[edi+ecx]
7=ZF set if equal [esi]=0
11=string.inc
12=esi,eax,ecx,edx
23=string/strcmpi.asm
[strcpy]
0=char *strcpy(char *des, char *src);
1=des *
2=src *
8=des
11=string.inc
12=eax ecx
13=.dd
14=.dd
16=strlen
17=memcpy
20=.dd
23=string/strcpy.asm
[strdate]
0=char *strdate(char *string, int date);
1=string
2=date
8=string
11=time.inc
12=eax
13=.dd
14=.dd
18=TimeToSystemTime
19=strsdate
20=.dd
23=time/strdate.asm
[strext]
0=char *strext(char *s1);
1=s1
8=char *
9=ZERO
11=string.inc
12=eax
13=.dd
16=strfn
17=strrchr
20=.dd
23=string/ext/strext.asm
[strfcat]
0=char *strfcat(char *des, char *path, char *file);
1=des
2=path
3=file
8=des
11=string.inc
12=eax
13=.dd
14=.dd
15=.dd
20=.dd
23=string/ext/strfcat.asm
[strfdate]
0=char *strfdate(char *string, FTIME *date);
1=string
2=date
8=string
11=time.inc
12=eax
13=.dd
14=S_FTIME
17=FileTimeToLocalFileTime
18=FileTimeToSystemTime
19=strsdate
20=.dd
23=time/strfdate.asm
[strfn]
0=char *strfn(char *path);
1=path
8=char *
11=string.inc
12=eax
13=.dd
20=.dd
23=string/ext/strfn.asm
[strftime]
0=char *strftime(char *string, S_FTIME *time);
1=string
2=time
8=string
11=time.inc
12=eax
13=.dd
14=S_FTIME
17=FileTimeToLocalFileTime
18=FileTimeToSystemTime
19=strstime
20=.dd
23=time/strftime.asm
[stricmp]
0=int stricmp(char *s1, char *s2);
1=s1
2=s2
8=0,1,-1
11=string.inc
12=eax
13=.dd
14=.dd
20=.dd
23=string/stricmp.asm
[strisquote]
0=int strisquote(char *, char *);
1=start
2=end
8=eax: pointer
9=cl:  char ' or "
10=eax 0 and ecx ptr 0
11=string.inc
12=eax ecx
13=.dd
14=.dd
20=.dd
21=.dd
23=string/ext/strisquote.asm
[strlen]
0=int strlen(char *string)
1=string
7=ZF set if zero
8=eax length
9=ecx length
11=string.inc
12=eax,ecx
13=.dd
20=.dd
21=.dd
23=string/strlen.asm
[strlwr]
0=char *strlwr(char *s1);
1=s1
8=s1
11=string.inc
12=eax
13=.dd
20=.dd
23=string/strlwr.asm
[strncmp]
0=int strncmp(char *s1, char *s2, int len);
1=s1
2=s2
3=len
8=0,1,-1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/strncmp.asm
[strncpy]
0=char *strncpy(char *des, char *src, int len);
1=des
2=src
3=len
8=des
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/strncpy.asm
[strnicmp]
0=int strnicmp(char *s1, char *s2, int len);
1=s1
2=s2
3=len
8=0,1,-1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/strnicmp.asm
[strnzcpy]
0=char *strnzcpy(char *dst, char *src, int len);
1=dst
2=src
3=len
8=dst
11=string.inc
12=eax ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/ext/strnzcpy.asm
[strpath]
0=char *strpath(char *s1);
1=s1
8=s1
11=string.inc
12=eax
13=.dd
15=strfn
20=.dd
23=string/ext/strpath.asm
[strrchr]
0=char *strrchr(char *string, char ch);
1=string
2=ch
8=char *
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/strrchr.asm
[strrev]
0=char *strrev(char *s1);
1=s1
8=s1
11=string.inc
12=eax
13=.dd
20=.dd
23=string/strrev.asm
[strsdate]
0=char *strsdate(char *string, STIME *date);
1=string
2=date
8=string
11=time.inc
12=eax
13=.dd
14=S_STIME
19=sprintf
20=.dd
23=time/strsdate.asm
[strshr]
0=char *strshr(char *, int);
1=string
2=char
8=string
11=string.inc
12=eax
13=.dd
14=.dd
20=.dd
23=string/ext/strshr.asm
[strspace]
0=char *strspace(char *string);
1=string
8=eax: pointer or NULL
9=ecx: char or pointer
11=string.inc
12=eax ecx
13=.dd
20=.dd
21=.dd
23=string/ext/strspace.asm
[strstart]
0=char *strstart(char *s1);
1=s1
8=char *
11=string.inc
12=eax
13=.dd
20=.dd
23=string/ext/strstart.asm
[strstime]
0=char *strstime(char *string, S_STIME *time);
1=string
2=time
8=string
11=time.inc
12=eax
13=.dd
14=.dd
19=sprintf
20=.dd
23=time/strstime.asm
[strstr]
0=char *strstr(char *s1, char *s2);
1=s1
2=s2
8=char *
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/strstr.asm
[strstri]
0=char *strstri(char *, char *);
1=buffer
2=string
11=string.inc
12=eax ecx
13=.dd
14=.dd
18=strlen
19=memstri
20=.dd
23=string/ext/strstri.asm
[strtime]
0=char *strtime(char *string, int time);
1=string
2=time
8=char *
11=time.inc
12=eax
13=.dd
14=.dd
18=TimeToSystemTime
19=strstime
20=.dd
23=time/strtime.asm
[strtok]
0=char *strtok(char *s1, char *s2);
1=s1
2=s2
8=tok
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/strtok.asm
[strtol]
0=long strtol(char *string);
1=string
8=edx:eax value
11=stdlib.inc
12=eax,edx
13=.dd
16=atol
17=xtol
20=.dq
23=stdlib/ext/strtol.asm
[strtrim]
0=int strtrim(char *s1);
1=s1
8=s1
11=string.inc
12=eax,ecx
13=.dd
20=.dd
23=string/ext/strtrim.asm
[strupr]
0=char *strupr(char *s1);
1=s1
8=s1
11=string.inc
12=eax
13=.dd
20=.dd
23=string/strupr.asm
[strxchg]
0=char *strxchg(char *buf, char *old, char *new)
1=buf
2=old
3=new
8=buf
11=string.inc
12=eax ecx
13=.dd
14=.dd
15=.dd
17=strlen
18=strstri
19=strmove
20=.dd
23=string/ext/strxchg.asm
[sys_errlist]
11=errno.inc
12=label dword
23=errno/sys_errlist.asm
[system]
0=int system(char *command);
1=command
8=BOOL
11=process.inc
12=eax,ecx,edx
13=.dd
14=malloc
15=strchr
16=strncpy
17=strlen
18=searchp
19=process
20=.dd
23=process/system.asm
[tdteditevent]
0=int tdteditevent(void);
8=event
11=consx.inc
12=eax,edx,ecx
15=dledit
20=.dd
23=consx/dobj/tdevent.asm
[_tell]
0=DWORD _tell(int handle);
1=handle
8=offset
11=io.inc
12=eax,edx,ecx
13=.dd
19=lseek
20=.dd
23=io/_tell.asm
[tgetevent]
0=int (*tgetevent)(void);
11=consx.inc
12=DWORD
23=consx/dobj/tgetevent.asm
[tgetline]
0=int tgetline(char *title, char *buf, int lsize, int bsize);
1=ttl
2=buf
3=lsize
4=bsize
8=result
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
16=.dd
18=dlopen
19=dlshow
20=.dd
23=consx/dobj/tgetline.asm
[thelp]
0=int (*thelp)(void);
11=consx.inc
12=DWORD
23=consx/dobj/thelp.asm
[__TimeToFT]
0=FTIME *__TimeToFT(int time, FTIME *lpFileTime);
1=time
2=lpFileTime
8=lpFileTime
11=time.inc
12=eax
13=.dd
14=S_FTIME
17=TimeToSystemTime
18=SystemTimeToFileTime
19=LocalFileTimeToFileTime
20=.dd
23=time/__TimeToFT.asm
[__TimeToST]
0=STIME *__TimeToST(int time, STIME *lpSystemTime);
1=time
2=lpSystemTime
8=lpSystemTime
11=time.inc
12=eax
13=.dd
14=S_STIME
20=S_STIME
23=time/__TimeToST.asm
[tmaxascii]
11=consx.inc
12=BYTE
[togetbitflag]
0=int togetbitflag(TOBJ *, int count, int flag);
1=TOBJ *
2=int
3=int
8=flag
11=consx.inc
12=eax,edx,ecx
13=S_TOBJ
14=.dd
15=.dd
20=.dd
23=consx/dobj/togetbitflag.asm
[tolower]
0=int tolower(int);
1=char
8=char
11=ctype.inc
12=eax
13=.dd
20=.dd
23=ctype/tolower.asm
[tosetbitflag]
0=void tosetbitflag(TOBJ *, int count, int flag, int bitflag);
1=tobj
2=count
3=flag
4=bitflag
11=consx.inc
12=eax,ecx,edx
13=S_TOBJ
14=.dd
15=.dd
16=.dd
23=consx/dobj/tosetbitflag.asm
[toupper]
0=int toupper(int);
1=ch
8=upper al
11=ctype.inc
12=eax
13=.dd
20=.dd
23=ctype/toupper.asm
[tupdate]
0=int (*tupdate)(void);
11=consx.inc
12=DWORD
23=consx/dobj/tupdate.asm
[tupddate]
0=void tupddate(void);
11=time.inc
12=eax,ecx,edx
17=strsdate
18=scputs
19=GetLocalTime
23=time/tupddate.asm
[tupdtime]
0=void tupdtime(void);
11=time.inc
12=eax,ecx,edx
23=time/tupdtime.asm
[unixtodos]
0=char *unixtodos(char *string);
1=string
8=string
11=string.inc
12=eax
13=.dd
20=.dd
23=string/ext/unixtodos.asm
[UpdateKeyEvent]
0=int UpdateKeyEvent(INPUT_RECORD *pInput);
1=pInput
8=eax: event
9=edx: keyshift
11=keyb.inc
12=eax,ecx,edx
13=INPUT_RECORD
20=.dd
21=.dd
23=consx/keyb/UpdateKeyEvent.asm
[validdrive]
0=int validdrive(int drive);
1=drive A: = 1
8=BOOL
11=direct.inc
12=eax,ecx,edx
13=.dd
19=GetLogicalDrives
20=.dd
23=direct/disk/validdrive.asm
[vsprintf]
0=int vsprintf(char *, char *, va_list);
1=buf
2=format
3=VARARG
8=count
11=stdio.inc
12=eax
13=.dd
14=.dd
15=...
19=_output
20=.dd
23=stdio/vsprintf.asm
[wcenter]
0=void wcenter(void *wp, int lsize, char *string);
1=wp
2=lsize
3=string
11=consx.inc
13=.dd
14=.dd
15=.dd
19=__wcpath
23=consx/robj/wcenter.asm
[wcloseff]
0=int wcloseff(int handle);
1=handle
8=0
11=io.inc
12=eax,ecx,edx
13=.dd
18=memcpy
19=FindClose
20=.dd
23=io/wffile.asm
[wcmemset]
0=void wcmemset(void *, int, size_t);
1=string
2=val
3=count
11=consx.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
23=consx/robj/wcmemset.asm
[wcpath]
0=void *wcpath(void *wp, int lsize, char *path);
1=wp
2=lsize
3=path
8=wp
9=path
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
19=__wcpath
20=.dd
21=.dd
23=consx/robj/wcpath.asm
[wcpbutt]
0=void *wcpbutt(void *wp, int lsize, int xsize, char *cp);
1=wp
2=lsize
3=xsize
4=cp
8=wp
11=consx.inc
12=eax,edx,ecx
13=.dd
14=.dd
15=.dd
16=.dd
20=.dd
23=consx/robj/wcpbutt.asm
[wcpopst]
0=void wcpopst(void *);
1=wp
11=consx.inc
12=eax,ecx,edx
13=.dd
19=rcxchg
23=consx/robj/wcpushst.asm
[wcpushst]
0=void wcpushst(void *, char *statusline);
1=wp
2=cp
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
17=wcputs
18=wcputw
19=rcxchg
23=consx/robj/wcpushst.asm
[wcputa]
0=void wcputa(WORD *wp, int l, int a);
1=wp
2=l
3=a
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
19=wcputxg
23=consx/robj/wcputa.asm
[wcputbg]
0=void wcputbg(void *wp, int count, int at);
1=wp
2=count
3=at
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
19=wcputxg
23=consx/robj/wcputbg.asm
[wcputf]
0=int _cdecl wcputf(void *, int lsize, int count, char *frm, ...);
1=wp
2=l
3=max
4=format
8=count
11=consx.inc
12=eax,edx
13=.dd
14=.dd
15=.dd
16=.dd
18=ftobufin
19=wcputs
20=.dd
23=consx/robj/wcputf.asm
[wcputfg]
0=void wcputfg(void *wp, int count, int at);
1=wp
2=count
3=at
11=consx.inc
12=eax,edx
13=.dd
14=.dd
15=.dd
19=wcputxg
23=consx/robj/wcputfg.asm
[wcputs]
0=int wcputs(void *wp, int l, int max, char *string);
1=wp
2=l
3=max
4=string
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
16=.dd
19=__wputs
23=consx/robj/wcputs.asm
[wcputw]
0=void wcputw(void *wp, int count, int w);
1=wp
2=count
3=w
11=consx.inc
13=.dd
14=.dd
15=.dd
23=consx/robj/wcputw.asm
[wcputxg]
11=consx.inc
12=ebx
23=consx/robj/wcputxg.asm
[wcscat]
0=wchar_t * wcscat(wchar_t *s1, const wchar_t *s2);
1=s1
2=s2
8=s1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/wcscat.asm
[wcschr]
0=wchar_t * wcschr(const wchar_t *wp, wchar_t w);
1=wp
2=w
11=string.inc
13=.dd
14=.dd
23=string/wcschr.asm
[wcscmp]
0=int wcscmp(const wchar_t *, const wchar_t *);
1=s1
2=s2
8=0,1,-1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/wcscmp.asm
[wcscpy]
0=wchar_t * wcscpy(wchar_t *, const wchar_t *);
1=s1
2=s2
8=s1
11=string.inc
12=eax
13=.dd
14=.dd
20=.dd
23=string/wcscpy.asm
[wcslen]
0=size_t wcslen(const wchar_t *);
1=s1
8=len
11=string.inc
12=eax,ecx
13=.dd
20=.dd
23=string/wcslen.asm
[wcsncat]
0=wchar_t * wcsncat(wchar_t *, const wchar_t *, size_t);
1=s1
2=s2
3=max
8=s1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/wcsncat.asm
[wcsncmp]
0=int wcsncmp(const wchar_t *, const wchar_t *, size_t);
1=s1
2=s2
3=len
8=0,1,-1
11=string.inc
13=.dd
14=.dd
15=.dd
20=.dd
23=string/wcsncmp.asm
[wcsncpy]
0=wchar_t * wcsncpy(wchar_t *, const wchar_t *, size_t);
1=s1
2=s2
3=len
8=s1
11=string.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
20=.dd
23=string/wcsncpy.asm
[wcspbrk]
0=wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
1=s1
2=s2
11=string.inc
12=eax
13=.dd
14=.dd
20=.dd
23=string/wcspbrk.asm
[wcsrchr]
0=wchar_t * wcsrchr(const wchar_t *, wchar_t);
1=s1
2=wc
8=&s1[?]
11=string.inc
12=eax,ecx
13=.dd
14=.dw
20=.dd
23=string/wcsrchr.asm
[wcsstr]
0=wchar_t * wcsstr(const wchar_t *, const wchar_t *);
1=s1
2=s2
11=string.inc
12=eax,ecx
13=.dd
14=.dd
20=.dd
23=string/wcsstr.asm
[wcstrcpy]
0=int wcstrcpy(char *, void *, int lsize);
1=cp
2=wp
3=lsize
8=count
11=consx.inc
12=eax,ecx
13=.dd
14=.dd
15=.dd
19=strtrim
20=.dd
23=consx/robj/wcstrcpy.asm
[wctitle]
0=void wctitle(void *wp, int lsize, char *title);
1=wp
2=lsize
3=title
11=consx.inc
12=eax
13=.dd
14=.dd
15=.dd
18=wcputw
19=wcenter
23=consx/robj/wctitle.asm
[wcunzip]
0=int wcunzip(void *des, void *src, int wcount);
1=des
2=src
3=wcount
8=count
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
18=rsunzipat
19=rsunzipch
20=.dd
23=consx/robj/wcunzip.asm
[wczip]
0=int wczip(void *des, void *src, int wcount);
1=des
2=src
3=wcount
8=count
11=consx.inc
12=eax,ecx,edx
13=.dd
14=.dd
15=.dd
20=.dd
23=consx/robj/wczip.asm
[wdlgopen]
0=int wdlgopen(char *path, char *mask, int);
11=wsub.inc
12=eax ecx edx
13=.dd
14=.dd
15=.dd
23=wsub/wdlgopen.asm
[wfindfirst]
0=int wfindfirst(char *mask, WFBLK *ff, int attrib);
1=mask
2=ff
3=attrib
8=handle
11=io.inc
12=eax,ecx,edx
13=.dd
14=S_WFBLK
15=.dd
19=FindFirstFile
20=.dd
23=io/wffile.asm
[wfindnext]
0=int wfindnext(WFBLK *ff, int handle);
1=ff
2=handle
8=0
11=io.inc
12=eax,ecx,edx
13=S_WFBLK
14=.dd
19=FindNextFile
20=.dd
23=io/wfindnext.asm
[wgetfile]
0=int wgetfile();
11=wsub.inc
12=eax ecx edx
23=wsub/wgetfile.asm
[wlongname]
0=char *wlongname(char *path, char *file);
1=path
2=file
8=name
11=io.inc
12=eax,ecx,edx
13=.dd
14=.dd
17=strfcat
18=strcpy
19=GetFullPathName
20=.dd
23=io/wconvert.asm
[wlongpath]
0=char *wlongpath(char *path, char *file);
1=path
2=file
8=eax: path
9=edx: file part
10=-- return stack!
11=io.inc
12=eax ecx edx
13=.dd
14=.dd
17=strfcat
18=strcpy
19=GetFullPathName
20=.dd
23=io/wlongpath.asm
[wschdrv]
0=int wschdrv(WSUB *, int)
1=WSUB *
2=drive
7=return value:
8=disk or 0
11=wsub.inc
12=eax ecx edx
13=.dd
14=.dd
16=GetFullPathName
18=strcpy
19=wssetflag
20=.dd
23=wsub/wschdrv.asm
[wsclose]
0=int wsclose(WSUB *)
1=WSUB *
6=return value:
8=count
11=wsub.inc
12=eax ecx
13=.dd
18=wsfree
19=free
20=.dd
23=wsub/wsclose.asm
[wscopy_open]
0=int _fastcall wscopy_open(char *src, char *dst);
1=eax: src
2=edx: dst
8=handle
11=wsub.inc
12=edx ecx eax
15=open
16=eropen
18=STDO
19=STDI
20=.dd
23=wsub/wscopy.asm
[wscopy_remove]
0=int _fastcall wscopy_remove(char *file)
1=file name
8=-1
11=wsub.inc
12=edx ecx eax
13=.dd
15=STDO
18=oclose
19=remove
20=.dd
23=wsub/wscopy.asm
[wsearch]
0=int wsearch(WSUB *, char *)
1=WSUB *
2=file name
8=index + 1 or 0
11=wsub.inc
12=eax
13=.dd
14=.dd
19=stricmp
20=.dd
23=wsub/wsearch.asm
[wsfblk]
0=FBLK *wsfblk(WSUB *, int);
1=WSUB *
2=index
8=eax: FBLK *
9=ecx: .fb_flag
10=edx: WSUB *
11=wsub.inc
12=eax ecx edx
13=.dd
14=.dd
20=.dd
21=.dd
22=.dd
23=wsub/wsfblk.asm
[wsffirst]
0=FBLK *wsffirst(WSUB *);
1=WSUB *
8=eax: FBLK *
9=ecx: .fb_flag
11=wsub.inc
12=eax ecx edx
13=.dd
19=fbffirst
20=.dd
21=.dd
23=wsub/wsffirst.asm
[wsfree]
0=int wsfree(WSUB *);
1=WSUB *
8=count
11=wsub.inc
12=eax ecx
13=.dd
19=free
20=.dd
23=wsub/wsfree.asm
[wshortname]
0=char *wshortname(char *path)
1=path
8=path or short name
11=io.inc
12=eax ecx edx
13=.dd
20=.dd
23=io/wshortname.asm
[wshortpath]
0=char *wshortpath(char *path, char *buffer);
1=path
2=buffer
8=buffer or NULL
11=io.inc
12=eax ecx edx
13=.dd
14=.dd
20=.dd
23=io/wshortpath.asm
[wsinit]
0=int wsinit(WSUB *)
1=WSUB
8=wssetflag or wslocal
11=wsub.inc
12=eax ecx edx
13=.dd
15=GetCurrentDirectory
16=SetCurrentDirectory
17=SetEnvironmentVariable
18=wslocal
19=wssetflag
20=.dd
23=WSUB/wsinit.asm
[wslocal]
0=int wslocal(WSUB *)
1=WSUB
8=1 or 0
11=wsub.inc
12=eax ecx edx
13=.dd
18=getcwd
19=wssetflag
20=.dd
23=WSUB/wslocal.asm
[wsmkdir]
0=int wsmkdir(char *path)
1=path
8=1 or -1
11=wsub.inc
12=eax ecx edx
13=.dd
18=ermkdir
19=mkdir
20=.dd
23=WSUB/wsmkdir.asm
[wsopen]
0=int wsopen(WSUB *);
1=WSUB *
8=BOOL
9=ZF
11=wsub.inc
12=eax ecx edx
13=.dd
16=malloc
17=free
18=memzero
20=.dd
23=wsub/wsopen.asm
[wsopenarch]
0=int wsopenarch(WSUB *wp);
1=wp
8=handle
11=wsub.inc
12=eax,ecx,edx
13=S_WSUB
15=strfcat
16=osopen
20=..d
23=wsub/wsopenarch.asm
[wssetflag]
0=int wssetflag(WSUB *)
1=WSUB *
8=disk type
11=wsub.inc
12=eax ecx edx
13=.dd
20=.dd
23=wsub/wssetflag.asm
[xtol]
0=long xtol(char *string);
1=string
8=edx:eax value
11=stdlib.inc
12=eax edx
13=.dd
20=.dq
23=stdlib/xtol.asm
