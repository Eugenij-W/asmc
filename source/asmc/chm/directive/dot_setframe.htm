<HTML><HEAD><TITLE>.SETFRAME</TITLE></HEAD>
<BODY>
Asmc Macro Assembler Reference
<H3>.SETFRAME</H3>

<p>Fills in the frame register field and offset in the unwind information using
the specified register (reg) and offset (offset). The offset must be a multiple
of 16 and less than or equal to 240. This directive also generates a
UWOP_SET_FPREG unwind code entry for the specified register using the current
prologue offset.</p>

<pre><b>.SETFRAME</b> reg, offset</pre>

<p>.SETFRAME allows ml64.exe users to specify how a frame function unwinds, and
is only allowed within the prologue, which extends from the PROC FRAME
declaration to the .ENDPROLOG directive. These directives do not generate code;
they only generate .xdata and .pdata. .SETFRAME should be preceded by
instructions that actually implement the actions to be unwound. It is a good
practice to wrap both the unwind directives and the code they are meant to
unwind in a macro to ensure agreement.</p>

<h4>Sample</h4>

<p>The following sample shows how to use a frame pointer:</p>

<pre>
; asmc -win64 frmex2.asm
; link /entry:frmex2 /subsystem:console frmex2.obj

    .code

frmex2 proc frame
    push rbp
    .pushreg rbp
    sub rsp,0x10
    .allocstack 0x10
    mov rbp, rsp
    .setframe rbp,0
    .endprolog

    ; modify the stack pointer outside of the prologue (similar to alloca)

    sub rsp,0x60

    ; we can unwind from the following AV because of the frame pointer
    mov rax,0
    mov rax,[rax] ; AV!

    add rsp,0x60
    add rsp,0x10
    pop rbp
    ret
frmex2 endp

    end
</pre>

<h4>See Also</h4>
<a href="index.htm">Directives Reference</a>
</BODY>
</HTML>
