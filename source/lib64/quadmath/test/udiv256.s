include quadmath.inc

    .code

udiv128 macro a, b, val, r
    local x, y, z, v
    .data
    x oword a,0
    y oword b,0
    z db 32 dup(0)
    v oword val,0
    .code
    _udiv256(addr x, addr y, addr z)
    .assert( z == r )
    mov rax,qword ptr x
    mov rdx,qword ptr x[8]
    mov rbx,qword ptr v
    mov rcx,qword ptr v[8]
    exitm<.assert( rax == rbx && rdx == rcx )>
    endm

main proc

    udiv128( 141592653589793238462, 10, 14159265358979323846, 2)
    udiv128( 1415926535897932384626, 10, 141592653589793238462, 6)
    udiv128( 14159265358979323846264, 10, 1415926535897932384626, 4)
    udiv128( 141592653589793238462643, 10, 14159265358979323846264, 3)
    udiv128( 1415926535897932384626433, 10, 141592653589793238462643, 3)
    udiv128( 14159265358979323846264338, 10, 1415926535897932384626433, 8)
    udiv128( 141592653589793238462643383, 10, 14159265358979323846264338, 3)
    udiv128( 1415926535897932384626433832, 10, 141592653589793238462643383, 2)
    udiv128( 14159265358979323846264338327, 10, 1415926535897932384626433832, 7)
    udiv128( 141592653589793238462643383279, 10, 14159265358979323846264338327, 9)
    udiv128( 1415926535897932384626433832795, 10, 141592653589793238462643383279, 5)
    udiv128( 14159265358979323846264338327950, 10, 1415926535897932384626433832795, 0)
    udiv128( 141592653589793238462643383279502, 10, 14159265358979323846264338327950, 2)
    udiv128( 1415926535897932384626433832795028, 10, 141592653589793238462643383279502, 8)
    xor eax,eax
    ret
main endp

    end
